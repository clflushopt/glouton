//! Implementation of glouton's abstract syntax tree.
//!
//! The glouton AST uses the apporach of a flat data structure where instead
//! of using traditional tree like structure where each node holds a pointer
//! in this case `Box<Node>`, nodes hold handles or reference indices to nodes
//! stored in an arena represented by a `Vec<Node>`.
//!
//! This data oriented approach has several pros, the first being that arenas
//! are borrow checker friendly. This is especially important in Rust where
//! an initial design might be invalidated because it doesn't have a borrow
//! checker friendly representation.
//!
//! The second argument for this is that complex self references and circular
//! references are not an issue anymore because there is no lifetime associated
//! with the reference you use, the lifetime is now associated with the entire
//! arena and the individual entries hold indices into the arena which are just
//! `u32`.
//!
//! Another argument although less impressive at this scale is speed, because
//! fetches aren't done via pointers and because AST nodes have nice locality
//! if your arena fits in cache then walking it becomes much faster than going
//! through the pointer fetch road.
//!
//! One point that must need to be though of before using the approach is how
//! the ownership of references is "oriented", i.e is your lifetime represented
//! as a tree of resources or a graph. This is important because the direction
//! or path of ownership could hinder the design.
//!
//! In our case the AST represents a program, the root node is an entry point
//! and the program itself is a sequence of *statements*. Where each statement
//! either represents control flow or expressions. Since expressions *will not*
//! reference *statements*, the AST can be represented as a tuple of `StmtPool`
//! and `ExprPool`.
//!
//! Where `StmtPool` holds the statement nodes, each node holds a `NodeRef`
//! that can reference either a statement or an expression, and `ExprPool`
//! holds `NodeRef` to expressions.
//!
//! We could be even more typesafe by using `ExprRef` and `StmtRef` but this
//! causes a problem since `StmtRef` can reference either an expression in
//! the `ExprPool` or a statement in the `StmtPool`.
//!
//! This approach is not new and has been used in LuaJIT, Zig, Sorbet, ECS
//! game engines and more, see[1] for more details.
//!
//! [1]: https://www.cs.cornell.edu/~asampson/blog/flattening.html

/// Node references are represented as `usize` handles to the AST arena
/// this avoides type casting everytime we want to access a node and down
/// casting when building references from indices.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct NodeRef(usize);

/// Expression nodes are used to represent expressions.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Expr {
    IntLiteral(i32),
}

/// Statement nodes are used to represent statements.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Stmt {
    Return(NodeRef),
}

/// `NodePool` represents an arena of AST nodes.
pub struct NodePool<T> {
    nodes: Vec<T>,
}

impl<T> NodePool<T> {
    /// Create a new node pool with a pre-allocated capacity.
    pub fn new() -> Self {
        Self {
            nodes: Vec::with_capacity(4096),
        }
    }

    /// Return a reference to a node given its `NodeRef`.
    pub fn get(&self, node_ref: NodeRef) -> &T {
        &self.nodes[node_ref.0 as usize]
    }

    /// Push a new expression into the pool.
    fn add(&mut self, expr: T) -> NodeRef {
        let node_ref = self.nodes.len();
        self.nodes.push(expr);
        NodeRef(node_ref)
    }
}

/// `AST` represents the AST generated by the parser when processing a list
/// of tokens.
pub struct AST {
    statements: NodePool<Stmt>,
    expressions: NodePool<Expr>,
}

#[cfg(test)]
mod tests {
    use crate::ast::NodePool;

    use super::{Expr, Stmt};

    #[test]
    fn can_create_and_use_node_pool() {
        let mut expr_pool = NodePool::new();
        let mut stmt_pool = NodePool::new();

        for i in 0..100 {
            let expr_ref = expr_pool.add(Expr::IntLiteral(42));
            let node_ref = stmt_pool.add(Stmt::Return(expr_ref));

            assert_eq!(expr_pool.get(expr_ref), &Expr::IntLiteral(42));
            assert_eq!(stmt_pool.get(node_ref), &Stmt::Return(expr_ref));
        }
    }
}
